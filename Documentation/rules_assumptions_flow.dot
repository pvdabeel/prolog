digraph rules_assumptions_bpmn {
  rankdir=TD;
  labelloc="t";
  label="portage-ng: rules/prover assumption flow (current implementation, BPMN-style)";
  fontsize=12;
  node [fontname="Helvetica", fontsize=10];
  edge [fontname="Helvetica", fontsize=9, arrowsize=0.7];

  subgraph cluster_test_harness {
    label="prover.pl : test_target_success/1 fallback chain";
    color="#888888";
    t_start [shape=circle, label="start"];
    t_strict [shape=box, label="strict:\nprinter:prove_plan([Target], ...)"];
    t_strict_ok [shape=diamond, label="success?"];
    t_blockers [shape=box, label="rules:with_assume_blockers(\n  printer:prove_plan(...)\n)"];
    t_blockers_ok [shape=diamond, label="success?"];
    t_conflicts [shape=box, label="rules:with_assume_conflicts(\n  printer:prove_plan(...)\n)"];
    t_done [shape=doublecircle, label="test target proven"];
  }

  subgraph cluster_blockers_conflicts {
    label="rules.pl : blocker + conflict assumption controls";
    color="#888888";
    b_start [shape=circle, label="start"];
    b_kind [shape=diamond, label="grouped_package_dependency\nstrength?"];
    b_weak [shape=box, label="weak:\nfindall(assumed(blocker(...)?{blocker_assumption_ctx}), ...)"];
    b_strong_split [shape=box, label="strong:\ngrouped_blocker_specs_partition(...,\nEnforceSpecs, AssumeSpecs)"];
    b_assume_blockers [shape=diamond, label="rules:assume_blockers?"];
    b_strong_assume_all [shape=box, label="assume all strong blockers:\nassumed(blocker(...)) for Enforce+Assume"];
    b_strong_enforce [shape=box, label="strict strong blockers:\nconstraint(blocked_cn(C,N):{ordset(EnforceSpecs)})\n+ assumed(blocker(...)) for AssumeSpecs"];
    b_conflict [shape=diamond, label="rule(conflict(A,B),...)"];
    b_conflict_assume [shape=box, label="rules:assume_conflicts ->\n[assumed(conflict(A,B))]"];
    b_conflict_fail [shape=box, label="strict conflict -> fail"];
    b_anyof_guard [shape=diamond, label="any_of_config_dep_ok/2\n(USE-dep option unsatisfied?)"];
    b_anyof_assume [shape=box, label="rules:assume_conflicts ->\nallow option (do not fail model build)"];
    b_anyof_fail [shape=box, label="strict -> reject option"];
  }

  subgraph cluster_grouped_dep {
    label="rules.pl : rule(grouped_package_dependency(no,C,N,PackageDeps):Action?{Context}, Conditions)";
    color="#888888";
    g_start [shape=circle, label="start"];
    g_split [shape=diamond, label="should_split_grouped_dep(PackageDeps)?"];
    g_split_emit [shape=box, label="emit one grouped dep per package_dependency/8\n(findall + sort)\n+ constraint(selected_cn_allow_multislot(C,N):{true})"];
    g_self_run [shape=diamond, label="Action == run AND self(C,N)?"];
    g_ok_self [shape=box, label="Conditions = []"];
    g_emptytree_core [shape=diamond, label="emptytree AND core_pkg(C,N)?"];
    g_ok_core [shape=box, label="Conditions = []"];
    g_keep_installed [shape=diamond, label="keep-installed fast path?\n(!emptytree, !deep, same-slot installed,\nversion+slot+build_with_use satisfied,\nand no --newuse mismatch)"];
    g_ok_installed [shape=box, label="Conditions = []"];
    g_slotreq [shape=box, label="SlotReq = merge_slot_restriction(...)"];
    g_select [shape=box, label="candidate selection:\n- explicit slot dep -> accepted_keyword_candidate\n- else selected_cn_candidate if slot-valid\n- else accepted_keyword_candidate"];
    g_self_guard [shape=diamond, label="candidate == self entry?"];
    g_self_installed [shape=diamond, label="if self candidate:\ninstalled(true)?"];
    g_version_guard [shape=diamond, label="all version constraints pass?"];
    g_pdepend [shape=diamond, label="PDEPEND edge in grouped deps?"];
    g_ctx_drop [shape=box, label="drop parent build_with_use/assumption_reason\nfor this dep edge"];
    g_use_guard [shape=diamond, label="candidate_satisfies_use_deps?"];
    g_use_slot [shape=box, label="process_build_with_use + process_slot"];
    g_action_path [shape=diamond, label="same-slot installed instance for update path?"];
    g_action_update [shape=box, label="ActionGoal = Candidate:update?{replaces(...)}\n(or rebuild_reason(build_with_use/newuse))"];
    g_action_install [shape=box, label="DepAction = (run -> install; else Action)\nActionGoal = Candidate:DepAction"];
    g_emit [shape=box, label="emit constraints + goal:\ncn_domain + cn_domain_reason + selected_cn\n+ selected_cn_allow_multislot (when SlotReq is slot/any_* )\n+ build/use constraints + ActionGoal"];
    g_sel_policy [shape=note, label="constraint_guard(selected_cn):\nstrict single concrete entry per (C,N) by default;\nper-slot multi-selection only when\nselected_cn_allow_multislot(C,N) exists"];
    g_deep_keep [shape=diamond, label="deep fallback keep-installed?\n(installed same-slot satisfies deps)"];
    g_ok_deep [shape=box, label="Conditions = []"];
    g_reason_call [shape=box, label="call explanation:assumption_reason_for_grouped_dep(...,_Reason)\nfor classification (not injected into context)"];
    g_assume [shape=box, label="fallback assumption:\nassumed(grouped_package_dependency(...):Action?{Ctx2})\nCtx2 augmented with domain_reason(cn_domain(...)) tags"];
  }

  subgraph cluster_reason {
    label="explanation.pl : assumption_reason_for_grouped_dep/6 (called on grouped fallback)";
    color="#888888";
    e_start [shape=circle, label="start"];
    e_any [shape=diamond, label="Any package exists?\n(category+name)"];
    e_missing [shape=box, label="Reason = missing"];
    e_need_inst [shape=diamond, label="self-hosting requires\ninstalled-only?"];
    e_inst_empty [shape=diamond, label="installed-only set empty?"];
    e_inst_req [shape=box, label="Reason = installed_required"];
    e_unmasked1 [shape=diamond, label="Any unmasked candidates?"];
    e_masked [shape=box, label="Reason = masked"];
    e_slot_any [shape=diamond, label="slot restriction yields\nany candidates?"];
    e_slot_bad [shape=box, label="Reason = slot_unsatisfied"];
    e_unmasked2 [shape=diamond, label="Any unmasked slot candidates?"];
    e_versions [shape=diamond, label="version_constraint_analysis:\nany candidate satisfies all constraints?"];
    e_ver_nocand [shape=box, label="Reason = version_no_candidate(Op,Ver)"];
    e_ver_conflict [shape=box, label="Reason = version_conflict"];
    e_keywords [shape=diamond, label="any candidate matches\nACCEPT_KEYWORDS?"];
    e_kw [shape=box, label="Reason = keyword_filtered"];
    e_other [shape=box, label="Reason = unsatisfied_constraints"];
  }

  subgraph cluster_update_txn {
    label="rules.pl : update action path (transactional, same-slot policy)";
    color="#888888";
    u_start [shape=circle, label="start"];
    u_has_replaces [shape=diamond, label="Context has replaces(...) ?"];
    u_txn [shape=box, label="rules:update_txn_conditions(...)"];
    u_installed_target [shape=diamond, label="target is installed and newer\nacceptable same-slot version exists?"];
    u_delegate_latest [shape=box, label="delegate to Latest:update?{replaces(Target)}"];
    u_target_not_installed [shape=diamond, label="target not installed?"];
    u_same_slot_old [shape=diamond, label="same-slot installed old version exists?"];
    u_fallback_install [shape=box, label="fallback: Target:install?{Context}"];
    u_noop [shape=box, label="installed and no acceptable newer -> []"];
    u_txn_detail [shape=box, label="update_txn_conditions does:\nrequired_use model + grouped install deps\n+ optional deep_update_goals\n+ use/slot constraints (+ download when needed)"];
  }

  t_start -> t_strict;
  t_strict -> t_strict_ok;
  t_strict_ok -> t_done [label="yes"];
  t_strict_ok -> t_blockers [label="no"];
  t_blockers -> t_blockers_ok;
  t_blockers_ok -> t_done [label="yes"];
  t_blockers_ok -> t_conflicts [label="no"];
  t_conflicts -> t_done;

  b_start -> b_kind;
  b_kind -> b_weak [label="weak"];
  b_kind -> b_strong_split [label="strong"];
  b_strong_split -> b_assume_blockers;
  b_assume_blockers -> b_strong_assume_all [label="yes"];
  b_assume_blockers -> b_strong_enforce [label="no"];
  b_conflict -> b_conflict_assume [label="assume_conflicts"];
  b_conflict -> b_conflict_fail [label="strict"];
  b_anyof_guard -> b_anyof_assume [label="yes + assume_conflicts"];
  b_anyof_guard -> b_anyof_fail [label="yes + strict"];

  g_start -> g_split;
  g_split -> g_split_emit [label="yes"];
  g_split -> g_self_run [label="no"];
  g_self_run -> g_ok_self [label="yes"];
  g_self_run -> g_emptytree_core [label="no"];
  g_emptytree_core -> g_ok_core [label="yes"];
  g_emptytree_core -> g_keep_installed [label="no"];
  g_keep_installed -> g_ok_installed [label="yes"];
  g_keep_installed -> g_slotreq [label="no"];
  g_slotreq -> g_select;
  g_select -> g_self_guard;
  g_self_guard -> g_self_installed [label="yes"];
  g_self_guard -> g_version_guard [label="no"];
  g_self_installed -> g_version_guard [label="yes"];
  g_self_installed -> g_select [label="no: try next"];
  g_version_guard -> g_pdepend [label="yes"];
  g_version_guard -> g_select [label="no: try next"];
  g_pdepend -> g_ctx_drop [label="yes"];
  g_pdepend -> g_use_guard [label="no"];
  g_ctx_drop -> g_use_guard;
  g_use_guard -> g_use_slot [label="yes"];
  g_use_guard -> g_select [label="no: try next"];
  g_use_slot -> g_action_path;
  g_action_path -> g_action_update [label="yes"];
  g_action_path -> g_action_install [label="no"];
  g_action_update -> g_emit;
  g_action_install -> g_emit;
  g_emit -> g_sel_policy [style=dashed, label="selection consistency policy"];
  g_emit -> g_split_emit [style=dashed, label="if split parent proving each child"];
  g_emit -> g_start [style=invis];
  g_slotreq -> g_deep_keep [style=dashed, label="no viable candidate branch"];
  g_deep_keep -> g_ok_deep [label="yes"];
  g_deep_keep -> g_reason_call [label="no"];
  g_reason_call -> g_assume;

  e_start -> e_any;
  e_any -> e_missing [label="no"];
  e_any -> e_need_inst [label="yes"];
  e_need_inst -> e_inst_empty [label="yes"];
  e_need_inst -> e_unmasked1 [label="no"];
  e_inst_empty -> e_inst_req [label="yes"];
  e_inst_empty -> e_unmasked1 [label="no"];
  e_unmasked1 -> e_masked [label="no"];
  e_unmasked1 -> e_slot_any [label="yes"];
  e_slot_any -> e_slot_bad [label="no"];
  e_slot_any -> e_unmasked2 [label="yes"];
  e_unmasked2 -> e_masked [label="no"];
  e_unmasked2 -> e_versions [label="yes"];
  e_versions -> e_ver_nocand [label="none per constraint"];
  e_versions -> e_ver_conflict [label="constraints conflict"];
  e_versions -> e_keywords [label="has version-ok candidates"];
  e_keywords -> e_kw [label="no"];
  e_keywords -> e_other [label="yes (still failed)"];

  u_start -> u_has_replaces;
  u_has_replaces -> u_txn [label="yes"];
  u_has_replaces -> u_installed_target [label="no"];
  u_installed_target -> u_delegate_latest [label="yes"];
  u_installed_target -> u_target_not_installed [label="no"];
  u_target_not_installed -> u_same_slot_old [label="yes"];
  u_target_not_installed -> u_noop [label="no"];
  u_same_slot_old -> u_txn [label="yes"];
  u_same_slot_old -> u_fallback_install [label="no"];
  u_txn -> u_txn_detail;

  g_action_update -> u_start [style=dashed, label="when ActionGoal is update"];
  g_reason_call -> e_start [style=dashed, label="classification path"];
  t_blockers -> b_assume_blockers [style=dashed, label="sets rules_assume_blockers=true"];
  t_conflicts -> b_conflict [style=dashed, label="sets rules_assume_conflicts=true"];
  t_conflicts -> b_anyof_guard [style=dashed, label="affects || model guard"];
}
