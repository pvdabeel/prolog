DESIGN: Learned Constraint Refinement + Wrong-Level Assumption Fix
===================================================================

PART 1: THE WRONG-LEVEL ASSUMPTION BUG
----------------------------------------

Location: rules.pl line 1246
  rules:grouped_dep_candidate_satisfies_effective_domain(...)

This check prunes candidates that conflict with the "effective domain"
which is the INTERSECTION of:
  a) The local dependency's version bounds (from PackageDeps)
  b) The Context's cn_domain(C,N) (from earlier resolutions)

The bug manifests when:
  1. Path A selects ppxlib-0.37.0-r1 (from core's ppxlib[any_same_slot])
  2. Path A's subtree adds cn_domain(dev-ml, ppxlib) = < 0.36.0
     (from ppx_sexp_conv-0.16.0-r2's dep)
  3. ppxlib-0.37.0-r1 is already in selected_cn
  4. The constraint guard detects ppxlib-0.37.0-r1 violates < 0.36.0
  5. Assumption is created: "ppxlib non-existent" from ppx_sexp_conv's
     perspective

  The assumption blames the CONSTRAINT (ppxlib < 0.36.0) rather than
  the SELECTION (ppxlib-0.37.0-r1 was wrong).

  Same for base/stdio: stdio-0.17.0-r1 (wrong selection) needs
  base=0.17*, but base-0.16.3-r1 (correct) is selected. Assumption
  blames base, but the real issue is stdio's version.

PART 2: TWO PROBLEMS, ONE SOLUTION
------------------------------------

Problem A: Wrong candidate selected (newest-first picks incompatible)
Problem B: Assumption at wrong level (blames constraint, not selection)

Both stem from the same root: the solver COMMITS to a candidate
(selected_cn) before knowing all transitive constraints, then when
a conflict is discovered, it CANNOT undo the commitment.

The Zeller/Vermeir solution addresses both:
  - Zeller: propagate constraints before selection (avoid wrong choice)
  - Vermeir: when constraints conflict, the lower-priority one yields
    (blame the right level)

PART 3: IMPLEMENTATION IN TWO PHASES
--------------------------------------

PHASE 1: Prover facility (generic, no domain knowledge)

  New predicates in prover.pl:
    prover:learned(Literal, Constraint) — lookup
    prover:learn(Literal, Constraint, Added) — store/merge
    Lifecycle: managed by with_cn_domain_reprove_state

  Test independently:
    - Store and retrieve constraints
    - Merge via val_hook (domain intersection)
    - Verify persistence across proof attempts
    - Verify cleanup on proof completion

  No exceptions, no catches, no retry logic in the prover.
  The prover just offers a store. Rules.pl decides when to use it.

PHASE 2: Rules integration (domain-specific, declarative)

  Step 2a: Learned domain lookup in grouped_dep_effective_domain
    - After computing local + context domain, intersect with any
      learned domain for this (C,N, Slot)
    - This narrows candidate selection BEFORE the wrong candidate
      is picked (Zeller's feature implication propagation)
    - Pure lookup, no control flow

  Step 2b: Constraint guard learns from conflicts
    - When selected_cn_domain_compatible_or_reprove detects that a
      selected candidate doesn't satisfy the domain:
      * Learn the domain as cn_domain(C, N, Slot)
      * The proof CONTINUES with assumptions (no throw, no retry)
      * On the NEXT proof attempt (from the existing reprove
        mechanism), the learned domain narrows candidates

    - When selected_cn_unique_or_reprove detects inconsistent domain:
      * Identify the lower-priority bound (from cn_domain_reason)
      * Learn a narrowing constraint for the ORIGIN package
        that introduced the lower-priority bound
      * This is the Vermeir fix: the lower-priority rule yields

  Step 2c: Trigger retry after learning
    - After prove_once completes, check if any new constraints were
      learned during this attempt
    - If yes AND attempt < max_retries: retry
    - This is the flag-based approach (no exceptions)
    - The retry benefits from ALL learned constraints

PHASE 3: Wrong-level assumption fix

  Currently: when grouped_dep_candidate_satisfies_effective_domain
  fails for ALL candidates, the assumption is created for (C, N)
  at line 1363.

  Fix: when the effective domain is inconsistent (comes from
  conflicting constraints), identify WHICH constraint was wrong
  and attribute the assumption to the ORIGIN of that constraint.

  This may not need any new code — if Phase 2b works correctly,
  the learned constraint for the origin package narrows its
  candidates on retry, and the downstream inconsistency never
  occurs. The wrong-level assumption disappears because the
  correct versions are selected from the start.

PART 4: MINIMAL TEST PLAN
---------------------------

Test 1: prover:learn/learned in isolation
  Goal: verify store works
  Method: manual calls in --shell mode
  Expected: learn stores, learned retrieves, merge intersects

Test 2: grouped_dep_effective_domain with learned constraint
  Goal: verify candidate narrowing
  Method: manually set a learned constraint, run --pretend for a
          target where the wrong candidate is usually selected
  Expected: the learned constraint narrows candidates, the correct
            version is selected

Test 3: Full integration
  Goal: verify the constraint guard learns and retry works
  Method: run --pretend for async_kernel-0.16.0
  Check: exit code 0, "Total: N actions" present, count non-existent
  Expected: fewer domain assumptions than baseline (7)

Test 4: No regressions
  Goal: verify existing behavior unchanged for non-conflicting targets
  Method: run --pretend for dev-ruby/rexml-3.4.2
  Expected: 0 non-existent, same plan as baseline

Test 5: --graph mode
  Goal: verify no crashes, no "Unknown message" errors
  Method: run --graph for a few targets that previously caused errors
  Expected: warnings for timeout/failures, but no prover_refine errors

PART 5: VERIFICATION PROTOCOL
-------------------------------

For EVERY test, check ALL of:
  1. Exit code (0 = no assumptions, 1 = cycle breaks only, 2 = domain assumptions)
  2. "Total: N actions" line present (proof completed)
  3. Count of "non-existent" lines
  4. No "Unknown message" or "prover_refine" in output
  5. Runtime (should be < 10 seconds for single targets)
