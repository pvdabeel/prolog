LEARNED CONSTRAINT FACILITY — APPROACH DOCUMENT
================================================

PROBLEM
-------
241 domain assumptions in emerge_ok targets caused by version series
conflicts. The solver picks the newest candidate (e.g., ppxlib-0.37.0-r1)
but transitive deps require an older series (e.g., ppxlib < 0.36.0).
Portage solves this with 14 backtrack iterations; portage-ng falls through
to assumptions.

SOLUTION THAT WORKED (async_kernel=0, rabbitmq=0, haskell=0)
------------------------------------------------------------
The working version had exactly these properties:

1. PROVER: Generic learned constraint store
   - prover:learned(Literal, Constraint) — lookup
   - prover:learn(Literal, Constraint, Added) — store/merge via val_hook
   - Store: prover_learned_constraints (assoc, managed by with_cn_domain_reprove_state)

2. PROVER: prover_refine(Literal, Constraint) exception
   - Caught by INNERMOST catch in prove_with_cn_domain_retries
   - Handler: learn the constraint, increment attempt, retry via recursive
     prove_with_cn_domain_retries call
   - Fallback (when Added=false): prove_once via with_cn_domain_reprove_disabled

3. RULES: Constraint guard throws prover_refine
   - In selected_cn_unique_or_reprove: when domain partitions into
     Allowed/Conflicting, throw prover_refine with slot-scoped literal
     cn_domain(C, N, Slot) and the Domain as constraint
   - In selected_cn_domain_compatible_or_reprove: when no selected
     candidate satisfies the domain, throw prover_refine
   - Guard: nb_current(prover_learned_constraints, _) — only throws
     when the store exists (inside prove/9 scope)

4. RULES: Learned domain consulted during candidate selection
   - In grouped_dep_effective_domain: after computing local + context
     domain, intersect with any learned domain for this (C,N,Slot)
   - Slot-scoped lookup: dep_slot_key extracts slot from PackageDeps

5. RULES: Constraint guard reorder
   - selected_cn_domain_compatible_or_reprove runs BEFORE
     selected_cn_unique_or_reprove (swapped from committed order)

WHY IT WORKED
-------------
The flow for async_kernel-0.16.0:

1. Proof runs. ppxlib-0.37.0-r1 selected (newest). Constraint guard
   detects selected_cn conflict with domain < 0.36.0.
2. prover_refine(cn_domain(dev-ml, ppxlib, '0'), domain(< 0.36.0)) thrown.
3. Handler catches, learns the domain, retries.
4. Retry: grouped_dep_effective_domain for ppxlib intersects local domain
   with learned < 0.36.0. ppxlib-0.33.0-r2 or older is selected.
5. Multiple iterations narrow further (sexplib0, ocaml, etc.).
6. Eventually the proof finds a consistent set (matching Portage's solution).

WHAT BROKE IT
-------------
The --graph batch mode (multi-threaded) threw "Unknown message: prover_refine"
errors because:

A. The prover_refine exception escaped prove/9 in some code paths:
   - handle_refine fallback calls prove_once without a catch
   - handle_cn_domain_reprove fallback calls prove_once without a catch
   - The exception propagated to tester.pl's generic catch which logged it

B. Attempts to fix the escape caused regressions:
   - Adding prover_refine_enabled flag: the flag wasn't properly set in all
     code paths, causing prover_refine to not fire at all
   - prove_absorbing_refine (recursive): caught all exceptions but caused
     cascading retries that ate the time budget (63s instead of 4s)
   - Deleting prover_learned_constraints in fallback: lost learned
     constraints, reverting to baseline behavior

C. The "already learned" check (\+ prover:learned(Literal, Domain)):
   - Prevents redundant throws for the same constraint
   - But if the same constraint fires repeatedly (ppxlib < 0.36.0 already
     learned, proof picks ppxlib-0.33.0-r2, which causes sexplib0 conflict,
     but sexplib0's domain is inconsistent so prover_refine is blocked for
     sexplib0, proof completes with assumptions)

THE CORE ARCHITECTURAL ISSUE
-----------------------------
The exception-based mechanism has a fundamental tension:

- The throw MUST be caught (otherwise --graph crashes)
- The throw MUST NOT be caught too eagerly (otherwise retries exhaust time)
- The throw guard MUST be true during normal proofs (otherwise no refinement)
- The throw guard MUST be false during fallback proofs (otherwise infinite loops)

The nb_current(prover_learned_constraints, _) guard worked for --pretend
but not for --graph because the store exists in ALL code paths (it's set up
by with_cn_domain_reprove_state at the start of prove/9). There's no way
to distinguish "inside the catch scope" from "inside the fallback scope"
using just the store's existence.

RECOMMENDED FIX
---------------
Instead of throwing exceptions from the constraint guard, use a FLAG-BASED
approach that doesn't require exception handling:

1. When constraint guard detects a conflict:
   - Call prover:learn(Literal, Constraint, Added)
   - Set a flag: nb_setval(prover_needs_retry, true)
   - DON'T throw — let the proof complete (with assumptions)

2. After prove_once returns, check the flag:
   - If prover_needs_retry is true AND Attempt < MaxRetries:
     - Reset the flag
     - Retry prove_once
   - Otherwise: return the proof result (with assumptions if any)

3. This avoids ALL exception-related issues:
   - No escaping exceptions
   - No catch/handler complexity
   - No fallback path issues
   - The proof always completes (never interrupted mid-way)

4. The retry uses the learned constraints naturally:
   - grouped_dep_effective_domain already consults prover:learned
   - On retry, the narrowed domains guide candidate selection
   - The proof discovers new constraints each iteration

5. Implementation:
   - prove_with_cn_domain_retries: after prove_once, check flag, retry
   - rules.pl: constraint guard calls learn + sets flag (no throw)
   - Remove ALL prover_refine exception handling
   - Remove prove_absorbing_refine

This is the Paludis approach adapted for portage-ng: learn constraints
incrementally, retry with accumulated knowledge, no exception-based
control flow.
