IN-DEPTH ANALYSIS: Learned Constraint Refinement for portage-ng
================================================================

1. THE PROBLEM IN ONE SENTENCE
-------------------------------
When the solver picks the newest version of a package (e.g., ppxlib-0.37.0-r1),
transitive dependencies may require an older version (e.g., ppxlib < 0.36.0),
but by the time this is discovered, the wrong choice has already been committed
into the proof tree.

2. WHAT WE HAVE THAT WORKS
---------------------------
a) Learned constraint store (prover:learn/3, prover:learned/2)
   - Generic key-value store (Literal → Constraint)
   - Merges via feature_unification:val_hook (domain intersection)
   - Managed by with_cn_domain_reprove_state lifecycle

b) Effective domain lookup (rules:learned_cn_domain/5)
   - grouped_dep_effective_domain intersects local domain with learned domain
   - Slot-scoped: cn_domain(C, N, Slot) as the literal key

c) Constraint guard detection
   - selected_cn_domain_compatible_or_reprove detects when selected_cn
     conflicts with cn_domain
   - selected_cn_unique_or_reprove detects when two selections for the
     same (C,N) violate uniqueness

d) Exception-based interrupt (prover_refine)
   - Throws prover_refine(Literal, Constraint)
   - Caught by innermost catch in prove_with_cn_domain_retries
   - Handler retries with learned constraint applied

3. WHAT DOESN'T WORK AND WHY
------------------------------

3.1 The Cascading Inconsistency Problem
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Flow for async_kernel-0.16.0:

  Attempt 0: prove_once
    → ppxlib-0.37.0-r1 selected (newest)
    → constraint guard: ppxlib domain < 0.36.0 conflicts
    → learn cn_domain(dev-ml, ppxlib, '0') = < 0.36.0
    → throw prover_refine → caught → retry

  Attempt 1: prove_once with learned ppxlib < 0.36.0
    → ppxlib-0.33.0-r2 selected (newest within < 0.36.0)
    → ppxlib-0.33.0-r2 depends on sexplib0 = 0.17*
    → core/base depends on sexplib0 = 0.16*
    → cn_domain for sexplib0 = {=0.16*, =0.17*} → INCONSISTENT
    → \+ domain_inconsistent guard BLOCKS the prover_refine throw
    → falls to reject-based path
    → reject mechanism handles it → eventually exhausts → disabled fallback
    → proof completes with 7 assumptions

  The INCONSISTENT domain for sexplib0 is the wall. We can't learn it
  (it would poison all sexplib0 lookups), and we can't throw for it
  (the guard blocks inconsistent domains).

3.2 Why the "Accidental" Version Worked (0 assumptions, 63 seconds)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The earlier version that gave async_kernel=0 had:
  - nb_current(prover_learned_constraints, _) as the throw guard
  - No \+ domain_inconsistent guard
  - The throw escaped from disabled fallbacks
  - A safety catch at prove/9 re-ran from Attempt=0

This gave UNLIMITED retries. Each retry:
  1. Learned one more constraint
  2. Threw prover_refine
  3. Handler retried OR exception escaped to safety catch
  4. Safety catch re-ran from Attempt=0 (resetting the budget)

After ~15 retries (63 seconds), enough constraints accumulated to find
the correct solution. But this was:
  - Unbounded (could loop forever for some targets)
  - Exception-unsafe (escaping exceptions in graph mode)
  - Slow (15× normal proof time)

3.3 Why Bounded Retries Don't Converge
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
With MaxRetries=20 and the inconsistency guard:
  - Attempt 0: learn ppxlib < 0.36.0, retry ✓
  - Attempt 1: sexplib0 inconsistent, can't learn → falls to reject path
  - Reject path uses 18 more attempts → exhausted
  - Final disabled proof: 7 assumptions

The prover_refine mechanism gets ONE chance (Attempt 0→1), then the
reject mechanism takes over and uses the remaining budget.

4. APPROACHES CONSIDERED
--------------------------

4.1 Non-accumulating retries (Portage-style)
  - Each retry starts fresh with only the latest mask
  - Doesn't work in portage-ng's proof architecture: can't "unmask"
    a reject without rebuilding the entire reject store

4.2 Positive preloading (Paludis-style)
  - Preload the correct CANDIDATE instead of learning a DOMAIN
  - Failed because ppxlib-0.33.0-r2 (the preloaded candidate) itself
    cascaded into sexplib0 conflicts
  - Would need iterative narrowing (try 0.33.0, fail, try 0.30.0)
    which is complex and fragile

4.3 Flag-based retry (no exceptions)
  - Learn constraint, set flag, let proof complete with assumptions,
    retry after completion
  - Failed because the proof COMPLETES with wrong assumptions; retrying
    produces the same wrong assumptions (the wrong subtree is already
    built when the flag is set)

4.4 Exception-based with bounded absorbing
  - Current approach: throw + catch + bounded retry
  - Works for single-conflict cases (rabbitmq)
  - Fails for cascading cases (async_kernel) due to inconsistent domains

5. THE KEY INSIGHT
-------------------
The problem is NOT in the retry mechanism. It's in the DOMAIN MODEL.

When sexplib0 has domain {=0.16*, =0.17*}, this is marked "inconsistent"
and the system gives up. But the inconsistency tells us something valuable:

  Two dependency paths require DIFFERENT versions of sexplib0.
  Path A (core/base): sexplib0 = 0.16*
  Path B (ppxlib-0.33.0-r2): sexplib0 = 0.17*

Since both can't be satisfied simultaneously, ONE of the paths must be
wrong. The question is: WHICH path is wrong?

Answer: Path B is wrong because ppxlib-0.33.0-r2 was itself selected as
a compromise (< 0.36.0). If we narrow ppxlib further to exclude 0.33.0-r2,
the sexplib0 inconsistency disappears.

Portage discovers this through 14 backtracks. Each backtrack masks one
more wrong package until only compatible versions remain.

6. PROPOSED SOLUTION: INCONSISTENCY-DRIVEN DOMAIN TIGHTENING
--------------------------------------------------------------

When cn_domain(C,N) is inconsistent, instead of giving up:

1. Identify which BOUND caused the inconsistency. The cn_domain_reason
   constraint tracks introduced_by(Origin, Action, version(Op, Ver)).

2. Find the Origin package whose bound conflicts with the MAJORITY of
   the other bounds (or with the "established" selection).

3. Learn a domain constraint for the ORIGIN package that EXCLUDES the
   version that introduced the conflicting bound.

Example for sexplib0:
  cn_domain = {=0.16*, =0.17*} (inconsistent)
  cn_domain_reason = {
    introduced_by(portage://base-0.16.3-r1, install, version(equal, 0.16*)),
    introduced_by(portage://ppxlib-0.33.0-r2, install, version(equal, 0.17*))
  }

  The =0.17* bound came from ppxlib-0.33.0-r2.
  Learn: cn_domain(dev-ml, ppxlib, '0') must EXCLUDE 0.33.0-r2.
  Concretely: learn cn_domain(dev-ml, ppxlib, '0') = < 0.33.0

  On retry: ppxlib < 0.33.0 → picks ppxlib-0.30.0-r2 → depends on
  sexplib0 = 0.16* → consistent with core/base → no more conflict.

This is exactly what Portage does via masking, but expressed as domain
narrowing.

7. IMPLEMENTATION PLAN
-----------------------

7.1 In rules.pl: Handle inconsistent domains in constraint guard

When selected_cn_unique_or_reprove detects domain inconsistency
(selected_cn_requires_same_slot_multiversion returns true):

  a) Get cn_domain_reason(C,N) from Constraints
  b) For each introduced_by(Origin, _, version(Op, Ver)) in reasons:
     - Look up Origin's (C', N') via cache:ordered_entry
     - Check if (C', N') already has a learned constraint
     - If Origin's version is the "minority" bound (conflicts with
       the majority or with existing learned constraints):
       * Compute an UPPER BOUND that excludes Origin's version
       * Learn cn_domain(C', N', Slot) with this upper bound
       * Throw prover_refine
  c) Fall through to existing behavior if no origin can be identified

7.2 Computing the exclusion bound

Given Origin = portage://dev-ml/ppxlib-0.33.0-r2:
  - Extract version: [0,33,0] with revision r2
  - Create bound: smaller([[0,33,0],...,'0.33.0'])
  - Learn: cn_domain(dev-ml, ppxlib, '0') = version_domain(any, [bound(smaller, ...)])
  - This narrows ppxlib to versions < 0.33.0

This is equivalent to Portage masking ppxlib-0.33.0-r2.

7.3 Guard against infinite narrowing

Each iteration narrows the domain further:
  ppxlib < 0.36.0 → ppxlib < 0.33.0 → ppxlib < 0.30.0 → ...

The narrowing converges because:
  - Each iteration excludes at least one version
  - There are finitely many versions
  - prover:learn merges (intersects) domains, so each iteration is
    strictly tighter
  - The Added == true check prevents retries without progress
  - MaxRetries bounds the total iterations

7.4 No package-specific code

This is completely generic:
  - Works for any (C,N) with inconsistent domain
  - Uses cn_domain_reason provenance (already computed)
  - No hardcoded categories or package names
  - The "minority bound" heuristic is based on the current proof state

8. COMPLEXITY AND PERFORMANCE
------------------------------
Each retry is a full proof (same as current behavior). The number of
retries is bounded by min(MaxRetries, number_of_versions_for_origin).
For the OCaml case: ~6 ppxlib versions → at most 6 retries for ppxlib
narrowing, plus the existing reject retries. Total: ~10-15 retries
(comparable to Portage's 14).

Each proof takes ~4 seconds for async_kernel. 15 retries = ~60 seconds.
This is the same as the "accidental" working version. For batch mode,
the per-target time limit (typically 2-3 seconds) would cap the retries.

9. ALTERNATIVE: FRESH-STATE RETRIES
-------------------------------------
Instead of accumulated rejects + learned constraints, each retry could
start with a FRESH proof state, carrying ONLY the learned constraints.
This matches Paludis more closely:
  - No reject set accumulation
  - No cascading blame
  - Each retry is a clean slate guided by learned domains

This requires changing prove_with_cn_domain_retries to NOT carry the
reject set across retries. The reject mechanism would still work within
a single retry, but rejects would be cleared between retries.

This is a larger refactor but would make the retry behavior more
predictable and Paludis-like.
