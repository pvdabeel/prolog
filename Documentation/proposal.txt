IMPLEMENTATION PROPOSAL
========================
Combining Zeller's Feature Logic with Vermeir/Van Nieuwenborgh's
Ordered Logic Programs for portage-ng dependency resolution.


1. THE SYNTHESIS
-----------------

Zeller teaches us: version sets narrow incrementally through feature
implications. Constraints propagate BEFORE selection.

Vermeir/Van Nieuwenborgh teach us: when constraints conflict, rule
ordering determines which yields. Inconsistency is not failure — it's
an opportunity to apply preferences.

Combined insight: dependency rules have a natural ordering (explicit
slot > any_same_slot > no constraint). When incremental narrowing
produces an inconsistent domain, the lowest-priority bound is dropped,
and its source is narrowed further. No backtracking needed.


2. THE MECHANISM: PRIORITIZED DOMAIN NARROWING
------------------------------------------------

2.1 Priority Assignment (from dependency metadata — already available)

  Priority 1 (highest): explicit slot+subslot dep
    e.g., core depends on base:0/0.16
    → bound: base = 0.16*

  Priority 2: explicit version constraint
    e.g., ppx_sexp_conv depends on ppxlib < 0.36.0
    → bound: ppxlib < 0.36.0

  Priority 3: any_same_slot (:=)
    e.g., core depends on ppxlib:=
    → no version bound, just "track the slot"

  Priority 4 (lowest): no constraint
    e.g., bdepend on dune (any version)

  The priority is ALREADY encoded in the SlotReq field of
  package_dependency: [slot(S), subslot(SS)] > [any_same_slot] > []

2.2 Prioritized Bounds in version_domain

  Currently, version_domain(Slots, Bounds) stores bounds as a flat list:
    [bound(equal, 0.16*), bound(equal, 0.17*)]

  Extend to carry priority:
    [bound(equal, 0.16*, priority(1)), bound(equal, 0.17*, priority(3))]

  When domain_meet merges two domains, bounds accumulate with their
  priorities. No change to the merge semantics.

2.3 Inconsistency Resolution via Priority

  Currently, domain_inconsistent checks if ANY version satisfies ALL
  bounds. If not → inconsistent → multi-slot fallback or assumption.

  New behavior: when domain_inconsistent is true, RESOLVE by dropping
  the lowest-priority bound:

    domain = [bound(equal, 0.16*, priority(1)),
              bound(equal, 0.17*, priority(3))]

    Inconsistent? Yes (no version is both 0.16* and 0.17*).
    Drop lowest priority: remove bound(equal, 0.17*, priority(3)).
    Resolved domain: [bound(equal, 0.16*, priority(1))]

    The dropped bound's source (ppxlib-0.33.0-r2, which introduced
    the =0.17* requirement on sexplib0) becomes a CONSTRAINT on
    ppxlib: exclude ppxlib-0.33.0-r2.

  This is Zeller's feature implication: dropping the bound implies
  a narrowing of the source package's version set.

  This is Vermeir's preferred answer set: the higher-priority rule
  (base:0/0.16 → sexplib0 = 0.16*) is satisfied; the lower-priority
  rule (ppxlib[any_same_slot] → sexplib0 = 0.17*) yields.

2.4 Propagation: Narrowing the Source

  When bound(equal, 0.17*, priority(3)) is dropped, we know:
  - It was introduced by ppxlib-0.33.0-r2 (from cn_domain_reason)
  - ppxlib-0.33.0-r2 must be excluded from ppxlib's version set

  This is a LEARNED CONSTRAINT on ppxlib:
    cn_domain(dev-ml, ppxlib) must exclude 0.33.0-r2

  Using Zeller's incremental narrowing: the ppxlib version set
  narrows from < 0.36.0 to < 0.33.0. The next candidate is
  ppxlib-0.30.0-r2, which depends on sexplib0 = 0.16*. Consistent.

  No retry needed. The constraint propagates within the SAME proof.


3. WHERE EACH CONCEPT LIVES
-----------------------------

3.1 version.pl — Extended domain model

  - Bounds carry priority metadata
  - domain_meet: accumulate bounds with priorities (unchanged merge)
  - domain_inconsistent: unchanged detection
  - NEW: domain_resolve_inconsistency(Domain, ResolvedDomain, DroppedBounds)
    Drops lowest-priority bounds until consistent.

3.2 rules.pl — Priority assignment

  - In cn_domain_constraints (line 1368): when creating cn_domain
    bounds from PackageDeps, attach priority from SlotReq:
      [slot(_), subslot(_)] → priority(1)
      explicit version bound → priority(2)
      [any_same_slot] → priority(3)
      [] → priority(4)

  - In constraint_guard: when domain_inconsistent is detected,
    call domain_resolve_inconsistency instead of falling to
    multi-slot or assumption. Use DroppedBounds to narrow the
    source package's domain via prover:learn.

  - In grouped_dep_effective_domain: unchanged — the resolved
    (consistent) domain is used for candidate selection.

3.3 prover.pl — Learned constraint store (already implemented)

  - prover:learn / prover:learned — unchanged
  - Lifecycle management — unchanged
  - The constraint propagation from dropped bounds uses prover:learn
    to store the narrowed domain for the source package.


4. FLOW FOR async_kernel-0.16.0
---------------------------------

  1. Proof starts. async_kernel-0.16.0 depends on core:0/0.16.

  2. core-0.16.1 selected. Its deps include:
     - base:0/0.16 (priority 1) → base = 0.16*
     - ppxlib[any_same_slot] (priority 3) → no bound on ppxlib

  3. ppxlib candidate selection. No learned constraint yet.
     Picks ppxlib-0.37.0-r1 (newest).

  4. ppxlib-0.37.0-r1 depends on ppx_sexp_conv with some constraint.
     ppx_sexp_conv-0.16.0-r2 is selected (from :0/0.16 dep).
     ppx_sexp_conv-0.16.0-r2 depends on ppxlib < 0.36.0 (priority 2).

  5. selected_cn for ppxlib: {0.37.0-r1}
     cn_domain for ppxlib: {bound(smaller, 0.36.0, priority(2))}
     Constraint guard: 0.37.0-r1 does NOT satisfy < 0.36.0.

     → domain_compatible_or_reprove fires.
     → Learn cn_domain(dev-ml, ppxlib, '0') = < 0.36.0.
     → Throw prover_refine (interrupt proof).

  6. Retry. Learned ppxlib < 0.36.0.
     ppxlib-0.33.0-r2 selected (newest within < 0.36.0).

  7. ppxlib-0.33.0-r2 depends on sexplib0 = 0.17* (priority 3).
     core/base depends on sexplib0 = 0.16* (priority 1).

  8. cn_domain for sexplib0:
       {bound(equal, 0.16*, priority(1)),
        bound(equal, 0.17*, priority(3))}
     domain_inconsistent → YES.

  9. NEW: domain_resolve_inconsistency:
     Drop bound(equal, 0.17*, priority(3)).
     Resolved domain: {bound(equal, 0.16*, priority(1))}.
     Dropped bound introduced_by ppxlib-0.33.0-r2.

  10. Learn: cn_domain(dev-ml, ppxlib, '0') narrowed further.
      Current: < 0.36.0. New: < 0.33.0 (exclude 0.33.0-r2).
      domain_meet: < 0.36.0 ∩ < 0.33.0 = < 0.33.0.

  11. Throw prover_refine with updated ppxlib domain.

  12. Retry. Learned ppxlib < 0.33.0.
      ppxlib-0.30.0-r2 selected.
      ppxlib-0.30.0-r2 depends on sexplib0 = 0.16* (priority 3).
      Consistent with core/base's = 0.16* (priority 1).
      No conflict. Proof succeeds.


5. WHAT CHANGES VS CURRENT CODE
---------------------------------

  version.pl:
  - bound/3 instead of bound/2 (add priority field)
  - NEW: domain_resolve_inconsistency/3
  - domain_allows_candidate: unchanged (ignores priority)

  rules.pl:
  - cn_domain_constraints: attach priority from SlotReq
  - constraint_guard (selected_cn_unique_or_reprove):
    when domain inconsistent, call domain_resolve_inconsistency
    instead of falling through to assumption
  - No more selected_cn_requires_same_slot_multiversion blocking

  prover.pl:
  - No changes beyond what's already implemented (learn/learned)


6. PROPERTIES
--------------

  - No backtracking / retry for inconsistency resolution (step 9-10
    happens within the same proof attempt via constraint propagation)
  - Retry only needed for the initial "wrong candidate" case (step 5-6),
    same as current prover_refine mechanism
  - Priority assignment is GENERIC (from SlotReq metadata, no
    package-specific code)
  - The ordering is a PARTIAL ORDER (same as Vermeir's framework):
    bounds with the same priority are kept; only strictly lower
    priority bounds are dropped
  - Convergence: each resolution drops at least one bound and narrows
    at least one version set → finite
  - Correctness: higher-priority constraints are always satisfied;
    lower-priority constraints yield only when necessary


7. RISKS AND MITIGATIONS
--------------------------

  Risk: Dropping a bound might be wrong (the lower-priority rule was
  actually correct).

  Mitigation: The dropped bound's source is narrowed, not removed.
  If the narrowing leads to an empty version set, the original
  inconsistency is restored and falls through to the assumption
  mechanism (same as current behavior — no regression).

  Risk: Priority assignment from SlotReq might not capture the true
  dependency importance.

  Mitigation: The priority is a heuristic for conflict resolution,
  not an absolute truth. If both bounds have the same priority,
  neither is dropped and the current behavior (assumption) applies.
  This preserves correctness for cases where the heuristic is
  insufficient.

  Risk: Extending bound/2 to bound/3 breaks existing code.

  Mitigation: Use a wrapper or optional third argument with default.
  Existing bound(Op, Ver) terms can be treated as priority(4) by
  default. Migration is incremental.
